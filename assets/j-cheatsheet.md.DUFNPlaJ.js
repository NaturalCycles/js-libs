import{_ as o,o as t,c as i,ae as c}from"./chunks/framework.BxjyvXIc.js";const h=JSON.parse('{"title":"j Cheatsheet","description":"","frontmatter":{},"headers":[],"relativePath":"j-cheatsheet.md","filePath":"j-cheatsheet.md"}'),d={name:"j-cheatsheet.md"};function a(l,e,s,n,r,p){return t(),i("div",null,[...e[0]||(e[0]=[c('<h1 id="j-cheatsheet" tabindex="-1">j Cheatsheet <a class="header-anchor" href="#j-cheatsheet" aria-label="Permalink to &quot;j Cheatsheet&quot;">â€‹</a></h1><p>Core rules and behaviors for <code>j</code> (AJV-based validation)</p><p>Basics</p><ul><li><code>j.object&lt;T&gt;(...)</code> requires an explicit type; missing it yields <code>never</code> at compile time.</li><li><code>j.object.infer(...)</code> is for composition only; do not validate with it directly.</li><li>Strict type matching: optional/required mismatches are compile-time errors.</li><li><code>j.enum(Enum)</code> supports both numeric and string enums; <code>j.enum([...])</code> for literal unions.</li><li><code>.isOfType&lt;T&gt;()</code> forces a schema/type check; mismatch yields <code>never</code>.</li><li><code>.castAs&lt;T&gt;()</code> overrides inferred input/output types without changing validation.</li></ul><p>Objects</p><ul><li>Default: additional properties are stripped.</li><li>Use <code>.allowAdditionalProperties()</code> to keep unknown keys.</li><li><code>j.object.record(keySchema, valueSchema)</code> returns <code>Record&lt;K, V&gt;</code> (strict typing).</li><li><code>j.object.withRegexKeys(...)</code> returns <code>StringMap&lt;V&gt;</code>; <code>j.object.stringMap(...)</code> is a shortcut.</li><li><code>j.object.dbEntity&lt;T&gt;(...)</code> expands <code>id/created/updated</code> and enforces a matching type.</li><li><code>.extend(...)</code> and <code>.concat(...)</code> preserve/merge types; use <code>.isOfType&lt;T&gt;()</code> to confirm final shape.</li><li><code>j.object.withEnumKeys(...)</code> creates an object with keys from an enum/array and value schema.</li></ul><p>Optional and nullable</p><ul><li><code>.optional()</code> adds <code>undefined</code> to the type.</li><li><code>.optional(values)</code> converts specific values to <code>undefined</code> (only when nested).</li><li><code>.nullable()</code> adds <code>null</code> to the type.</li></ul><p>Transforms</p><ul><li>String transforms like <code>.trim()</code> and <code>.toLowerCase()</code> only apply when nested in an object or array.</li><li><code>j.set(...)</code> accepts any iterable input; output is a <code>Set</code>.</li><li><code>j.buffer()</code> accepts any Buffer input; output is a <code>Buffer</code>.</li><li>Regex can set <code>{ msg }</code> or <code>{ name }</code> for a clearer error message.</li></ul><p>Validation</p><ul><li><code>schema.validate()</code> mutates input by default.</li><li>Use <code>{ mutateInput: false }</code> to avoid mutation.</li><li><code>schema.create(schema).getValidationResult(...)</code> returns <code>[error, output]</code> (output may be transformed).</li><li><code>schema.validate()</code> strips unknown properties unless <code>.allowAdditionalProperties()</code> is set.</li></ul><p>Where to look</p><ul><li>These files live under <code>packages/nodejs-lib/src/validation/ajv/</code>.</li><li><code>j</code> API + intent: <code>j.readme.md</code></li><li>Type behavior: <code>jsonSchemaBuilder.test.ts</code></li><li>Runtime behavior: <code>ajv.validations.test.ts</code> and <code>ajv.test.ts</code></li></ul>',14)])])}const m=o(d,[["render",a]]);export{h as __pageData,m as default};
